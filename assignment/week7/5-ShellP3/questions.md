1. Your shell forks multiple child processes when executing piped commands. How does your implementation ensure that all child processes complete before the shell continues accepting user input? What would happen if you forgot to call `waitpid()` on all child processes?

My implementation uses `waitpid()` to ensure all child processes are complete before continuing. If neither `wait()` nor `waitpid()` were used, then the child processes would become zombies and lead to undefined behavior.

2. The `dup2()` function is used to redirect input and output file descriptors. Explain why it is necessary to close unused pipe ends after calling `dup2()`. What could go wrong if you leave pipes open?

We have to use `close()` after `dup2()` to ensure that we don't unintentionally hang our process as well as to avoid memory leaks from improper EOF signaling in our pipes.

3. Your shell recognizes built-in commands (`cd`, `exit`, `dragon`). Unlike external commands, built-in commands do not require `execvp()`. Why is `cd` implemented as a built-in rather than an external command? What challenges would arise if `cd` were implemented as an external process?

If `cd` were implemented as an external command then we would be passing the directory we moved to as either input or output within our pipes but it wouldn't be effective as the main shell would not be moving its directory. This is also why it makes sense as a built-in even before the implementation of pipes. In Linux itself, `cd` is a shell built-in that only affects the shell itself and cannot be used with pipes.

4. Currently, your shell supports a fixed number of piped commands (`CMD_MAX`). How would you modify your implementation to allow an arbitrary number of piped commands while still handling memory allocation efficiently? What trade-offs would you need to consider?

My solution for allocating memory for the `command_list_t` struct already semi-handles this. I did not want to `alloc()` for the entirety of the array (8 commands) when the program starts although it might be a more performant option because I wanted to try dynamically scaling up the amount of command structs as needed from the users' input. I always allocate one struct to start the program with and if the user has multiple commands then I use `alloc_cmd_buff()` to to generate more storage as required. After executing the commands I use `clear_cmd_buff()` in a loop to clear out all the input from the user but I don't call `free_cmd_list()` until the program has completed, and all this function does is call `free_cmd_buff` for any allocated `cmd_buff_t` struct in the list - this ensures that the program only scales as the user adds more commands and it keeps the memory it allocated until it is closed in the event that memory needs to be re-used (to potentially save another `alloc()` call). This does add some complexity and if `CMD_MAX` were removed there is a chance this program could freeze from allocating so many resources if there were a lot of piped commands given, so performance would need to be considered.